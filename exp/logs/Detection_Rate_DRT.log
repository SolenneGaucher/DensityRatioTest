srun: job 274151 queued and waiting for resources
srun: job 274151 has been allocated resources
> rm(list=ls())
> set.seed(0)
> setwd("/workdir2/solenne.gaucher/FlowCytometry")
> #setwd("~/Desktop/Recherche/postdoc/FlowCyto/SimulationsV2")
> 
> # Load packages
> library(doParallel)
Le chargement a nécessité le package : foreach
Le chargement a nécessité le package : iterators
Le chargement a nécessité le package : parallel
> library(partykit)
Le chargement a nécessité le package : grid
Le chargement a nécessité le package : libcoin
Le chargement a nécessité le package : mvtnorm
> library(foreach)
> library(lubridate)

Attachement du package : ‘lubridate’

Les objets suivants sont masqués depuis ‘package:base’:

    date, intersect, setdiff, union

> 
> ################################## Distributions ##############################
> s <- matrix(c(1/100, 0, 0, 1/100), ncol = 2, nrow = 2)
> # Define distribution f0
> 
> rf0 <- function(n, setting){
+   if (setting == "A"){
+     m0 <- c(3/10, 3/10)
+   }else if (setting == "B"){
+     m0 <- c(4/10, 4/10)
+   }else{
+     m0 <- c(4/10, 4/10)
+   }
+   return(tmvtnorm::rtmvnorm(n, m0, s, lower = c(0,0), upper = c(1,1)))
+ }
> 
> # Define distribution f1
> rf1 <- function(n, setting){
+   if (setting == "A"){
+     m0 <- c(7/10, 7/10)
+   }else if (setting == "B"){
+     m0 <- c(6/10, 6/10)
+   }else{
+     m0 <- c(5/10, 5/10)
+   }
+   return(tmvtnorm::rtmvnorm(n, m0, s, lower = c(0,0), upper = c(1,1)))
+ }
> 
> ################################ Choose parameters for this simulation ####################################################
> # n_train = n0_train + n1_train
> n_train_choice <- as.integer(exp(seq(log(1000), log(1000000), length.out = 10)))+1 # values for n_train
> p0 <- 0.7
> theta_choice <-  c(0, exp(seq(log(0.0003), log(0.3), length.out = 30))) # values for theta
> n_sim <- 100 # number of simulations
> B_iterations <- 300 # number of repetitions for the bootstrap quantile
> K_max <- 15 # maximal number of bins
> alpha <- 0.05
> 
> ################################ For parallelization ############################
> n.cores <- parallel::detectCores() - 1
> my.cluster <- parallel::makeCluster(
+   n.cores, 
+   type = "PSOCK"
+ )
> doParallel::registerDoParallel(cl = my.cluster)
> 
> ########################### Simulations ########################### 
> print(paste("We begin the experiment, time is ", now()))
[1] "We begin the experiment, time is  2024-02-16 16:13:12"
> for (setting in c("A", "B", "C")){
+   for (n_train in n_train_choice){
+     res_exp <- foreach(i = 1:n_sim, .combine=rbind) %dopar% {
+       source("utils/user_defined_split.R")
+       source("utils/aux.R")
+       source("utils/test_dr.R")
+       source("utils/part_choice.R")
+       
+       # Simulate data for X_part^0, X_part^1, X_est^0, X_est^1
+       n0_part <- as.integer(p0*n_train/2)
+       n1_part <- as.integer((1-p0)*n_train/2)
+       n_part <- n0_part + n1_part
+       Xpart <- rbind(rf0(n0_part, setting),rf1(n1_part, setting))
+       data_part <- data.frame(Xpart)
+       data_part$Y <- c(rep(0, n0_part), rep(1, n1_part))
+       
+       n0_est <- as.integer(p0*n_train/2)
+       n1_est <- as.integer((1-p0)*n_train/2)
+       n_est <- n0_est + n1_est
+       Xest <- rbind(rf0(n0_est, setting),rf1(n1_est, setting))
+       data_est <- data.frame(Xest)
+       data_est$Y <- c(rep(0, n0_est), rep(1, n1_est))
+       
+       n_test <- as.integer(n_train/10)
+       
+       # Define the parameters for growing the partition sequence
+       Kmax <- 15
+       u <- log(4*Kmax/alpha)
+       t <- log(2/alpha)
+       epsilon0 = max(3*u/n0_part, t/n_test)
+       epsilon1 = max(sqrt(3*u/n1_part),epsilon0)
+       parms_part = list(epsilon0 = epsilon0, epsilon1 = epsilon1, n0 = n0_part, n1 = n1_part)
+       
+       # Choose the partition sequence using respectively the density ratio criteria and the gini index
+       full_tree <- rpart::rpart(Y ~ X1 + X2, data = data_part,
+                                 method = method_dr(), parms = parms_part, cp = 0, maxdepth = 10, minbucket = sqrt(n1_part))
+       
+       # Define the parameters for choosing the best partition
+       u <- log(4*Kmax/alpha)
+       t <- log(2/alpha)
+       epsilon0 = max(3*u/n0_est, t/n_test)
+       epsilon1 = max(sqrt(3*u/n1_est),epsilon0)
+       parms_est = list(epsilon0 = epsilon0, epsilon1 = epsilon1, n0 = n0_est, n1 = n1_est)
+       
+       # Choose the best partition in the sequence
+       pruned_tree <- prune_dr(full_tree, data_est, parms_est, Kmin = 3)
+       partition <- as.party(pruned_tree$pruned_tree)
+       
+       # Set the parameters for the test
+       K <- pruned_tree$K
+       u <- log(4*K/alpha)
+       t <- log(2/alpha)
+       epsilon0 = max(3*u/n0_est, t/n_test)
+       epsilon1 = max(sqrt(3*u/n1_est),epsilon0)
+       parms_est = list(epsilon0 = epsilon0, epsilon1 = epsilon1, 
+                        n0 = n0_est, n1 = n1_est, n_test = n_test,
+                        u = u, t = t, K = K)
+       
+       # Conduct the test
+       res <- as.data.frame(matrix(nrow = 0, ncol = 5))
+       for (theta in theta_choice){
+         n1_test <- as.integer(theta*n_test)
+         n0_test <- n_test - n1_test
+         if (n1_test >= 1){
+           Xtest <- rbind(rf0(n0_test, setting),rf1(n1_test, setting))
+         }else{
+           Xtest <- rf0(n0_test, setting)
+         }
+         data_test <- data.frame(Xtest)
+         res <- rbind(res, c("DRT", setting, n_train, theta, 
+                             test_dr(data_est, data_test, parms_est, partition)))
+       }
+       names(res) <- c("method" , "setting", "n_train", "theta", "result")
+       return(res)
+     }
+     print(paste("setting = ", setting,", n_train = ", n_train, ", time is ", now()))
+     saveRDS(res_exp, paste("results/Detection_rate_DRT/setting_",setting, "_ntrain", n_train,".rds", sep = ""))
+   }
+ }
[1] "setting =  A , n_train =  1000 , time is  2024-02-16 16:13:20"
[1] "setting =  A , n_train =  2155 , time is  2024-02-16 16:13:23"
[1] "setting =  A , n_train =  4642 , time is  2024-02-16 16:13:28"
[1] "setting =  A , n_train =  10000 , time is  2024-02-16 16:13:39"
[1] "setting =  A , n_train =  21545 , time is  2024-02-16 16:14:05"
[1] "setting =  A , n_train =  46416 , time is  2024-02-16 16:15:03"
[1] "setting =  A , n_train =  1e+05 , time is  2024-02-16 16:17:10"
[1] "setting =  A , n_train =  215444 , time is  2024-02-16 16:49:42"
[1] "setting =  A , n_train =  464159 , time is  2024-02-16 17:07:44"
[1] "setting =  A , n_train =  1e+06 , time is  2024-02-16 17:32:56"
[1] "setting =  B , n_train =  1000 , time is  2024-02-16 17:33:10"
[1] "setting =  B , n_train =  2155 , time is  2024-02-16 17:33:13"
[1] "setting =  B , n_train =  4642 , time is  2024-02-16 17:33:18"
[1] "setting =  B , n_train =  10000 , time is  2024-02-16 17:33:31"
[1] "setting =  B , n_train =  21545 , time is  2024-02-16 17:33:57"
[1] "setting =  B , n_train =  46416 , time is  2024-02-16 17:34:57"
[1] "setting =  B , n_train =  1e+05 , time is  2024-02-16 17:37:14"
[1] "setting =  B , n_train =  215444 , time is  2024-02-16 17:42:01"
[1] "setting =  B , n_train =  464159 , time is  2024-02-16 17:52:14"
[1] "setting =  B , n_train =  1e+06 , time is  2024-02-16 18:14:49"
[1] "setting =  C , n_train =  1000 , time is  2024-02-16 18:14:52"
[1] "setting =  C , n_train =  2155 , time is  2024-02-16 18:14:55"
[1] "setting =  C , n_train =  4642 , time is  2024-02-16 18:15:00"
[1] "setting =  C , n_train =  10000 , time is  2024-02-16 18:15:12"
[1] "setting =  C , n_train =  21545 , time is  2024-02-16 18:15:36"
[1] "setting =  C , n_train =  46416 , time is  2024-02-16 18:16:30"
[1] "setting =  C , n_train =  1e+05 , time is  2024-02-16 18:18:27"
[1] "setting =  C , n_train =  215444 , time is  2024-02-16 18:22:46"
[1] "setting =  C , n_train =  464159 , time is  2024-02-16 18:32:53"
[1] "setting =  C , n_train =  1e+06 , time is  2024-02-16 18:55:20"
> parallel::stopCluster(cl = my.cluster)
> 
